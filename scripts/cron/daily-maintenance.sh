#!/bin/bash
# Master Runner: Daily Maintenance Aggregator
# Schedule: 0 9 * * * (daily 9 AM — after all individual jobs)
# Verifies heartbeats, aggregates health, weekly ntfy proof

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "$SCRIPT_DIR/../lib/env.sh"
source "$SCRIPT_DIR/../lib/notify.sh"

REPORTS_DIR="$PAI_DIR/GOVERNANCE/REPORTS"
LOG="$REPORTS_DIR/maintenance.log"
REPORT="$REPORTS_DIR/daily-health-$(date +%Y-%m-%d).md"
NOW=$(date +%s)
MAX_AGE=93600  # 26 hours in seconds

# All expected heartbeats (daily jobs)
DAILY_JOBS=(
    "log-rotation"
    "state-cache"
    "jsonl-compaction"
    "dream-cleanup"
    "debug-cleanup"
    "feedly-digest"
    "landscape-scan"
    "config-validator"
    "disk-usage"
)

# Weekly jobs (only checked on Sunday)
WEEKLY_JOBS=(
    "work-hygiene"
    "git-state"
    "harvest-expiry"
    "upstream-sync"
)

log() {
    echo "[$(date -Iseconds)] [daily-maintenance] $*" >> "$LOG"
}

log "=== Daily maintenance aggregation starting ==="

PASS=0
FAIL=0
SKIP=0
STATUS_LINES=""
DAY_OF_WEEK=$(date +%u)  # 1=Monday, 7=Sunday

check_heartbeat() {
    local job="$1"
    local max_age="$2"
    local hb_file="$REPORTS_DIR/.heartbeat-${job}"

    if [[ ! -f "$hb_file" ]]; then
        STATUS_LINES="${STATUS_LINES}\n| $job | MISSING | Never ran |"
        FAIL=$((FAIL + 1))
        return 1
    fi

    local hb_time
    hb_time=$(cat "$hb_file" 2>/dev/null || echo 0)
    local age=$((NOW - hb_time))
    local age_hours=$((age / 3600))

    if [[ $age -le $max_age ]]; then
        STATUS_LINES="${STATUS_LINES}\n| $job | PASS | ${age_hours}h ago |"
        PASS=$((PASS + 1))
        return 0
    else
        STATUS_LINES="${STATUS_LINES}\n| $job | STALE | ${age_hours}h ago |"
        FAIL=$((FAIL + 1))
        return 1
    fi
}

# Check daily jobs (26h threshold)
for job in "${DAILY_JOBS[@]}"; do
    check_heartbeat "$job" "$MAX_AGE" || true
done

# Check weekly jobs only on Sunday (170h = ~7 days + buffer)
if [[ $DAY_OF_WEEK -eq 7 ]]; then
    for job in "${WEEKLY_JOBS[@]}"; do
        check_heartbeat "$job" 612000 || true  # 170h
    done
else
    for job in "${WEEKLY_JOBS[@]}"; do
        STATUS_LINES="${STATUS_LINES}\n| $job | SKIP | Weekly (Sunday only) |"
        SKIP=$((SKIP + 1))
    done
fi

TOTAL=$((PASS + FAIL + SKIP))

# Write report
cat > "$REPORT" << EOF
# Daily Health Report — $(date '+%Y-%m-%d %H:%M')

## Summary
- **Pass:** $PASS
- **Fail:** $FAIL
- **Skip:** $SKIP (weekly, not due)
- **Total:** $TOTAL

## Job Status

| Job | Status | Last Run |
|-----|--------|----------|$(echo -e "$STATUS_LINES")

---
*Generated by daily-maintenance.sh*
EOF

log "Health: $PASS pass, $FAIL fail, $SKIP skip"

# Alert on failures
if [[ $FAIL -gt 0 ]]; then
    pai_notify "PAI: Maintenance Failures" "$FAIL of $TOTAL jobs failed heartbeat check" 4
fi

# Weekly heartbeat proof (Sundays only) — proves alerting path is alive
if [[ $DAY_OF_WEEK -eq 7 ]]; then
    pai_notify "PAI: Weekly Health Proof" "System alive. $PASS/$TOTAL jobs healthy." 2
    log "Sent weekly heartbeat proof via ntfy"
fi

# Self-cleaning: delete reports >30 days
find "$REPORTS_DIR" -name "daily-health-*.md" -mtime +30 -delete 2>/dev/null || true
find "$REPORTS_DIR" -name "config-health-*.md" -mtime +30 -delete 2>/dev/null || true
find "$REPORTS_DIR" -name "work-hygiene-*.md" -mtime +30 -delete 2>/dev/null || true
find "$REPORTS_DIR" -name "disk-usage-*.md" -mtime +30 -delete 2>/dev/null || true

date +%s > "$REPORTS_DIR/.heartbeat-daily-maintenance"

log "=== Daily maintenance aggregation complete ==="
exit 0
